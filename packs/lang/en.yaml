# packs/lang/en.yaml
# English base
#
# Keep this file accent-neutral as much as possible. Put UK-specific
# pronunciation tweaks in `en-gb.yaml` and US-specific ones in `en-us.yaml`.

settings:
  # English tends to sound more natural if stressed syllables are not *too* slowed.
  # This also helps teen numbers (e.g. "14") not feel like the ending is clipped.
  primaryStressDiv: 1.4
  secondaryStressDiv: 1.1

  # English sounds clearer with explicit stop closures.
  # Stop closures help clarity, but using them *everywhere* can make the voice feel clicky,
  # especially for short chunks like key echo / character echo.
  # Keep closures mostly after vowels/clusters, and keep the gaps short.
  stopClosureMode: vowel-and-cluster
  stopClosureVowelGapMs: 20
  stopClosureVowelFadeMs: 4
  stopClosureClusterGapMs: 16
  stopClosureClusterFadeMs: 3

  # English: insert short aspiration after unvoiced stops in the right contexts.
  postStopAspirationEnabled: true

  # Keep your existing English long /uː/ shortening behavior (matches your Python logic).
  englishLongUShortenEnabled: true
  englishLongUWordFinalScale: 0.95
  englishLongUKey: "ᵾ"

  # Long vowels (ː) in word-final consonant clusters can sound over-held
  # in a formant synth (e.g. "rules" /ruːlz/, "dialog" /dʌɪəˌlɔːg/).
  # This additional scale shortens length-marked vowels when they are the
  # last vowel in a word and followed by final consonants.
  #
  # Tune per-language if needed.
  lengthenedVowelFinalCodaScale: 0.90

  # Single-word utterances (key echo / word-by-word reading) are often queued as
  # separate chunks. Without an explicit fade-to-silence frame, the final voiced
  # phoneme can sound clipped (notably on /ɹ/ and /uː/).
  singleWordTuningEnabled: true
  # Extra hold to add to the final voiced vowel/liquid/nasal (ms at speed=1.0).
  singleWordFinalHoldMs: 45
  # Fade to silence to append after single-word utterances (ms at speed=1.0).
  singleWordFinalFadeMs: 18
  # If the caller uses clauseType ',' for continuation, use a statement contour
  # for isolated words/letters to avoid the odd "comma rise".
  singleWordClauseTypeOverride: "."
  singleWordClauseTypeOverrideCommaOnly: true


  # Keep length scaling close to the global default.
  # Over-lengthening can make clusters (like "-dcast") sound overly separated.

  spellingDiphthongMode: none
  liquidDynamicsEnabled: false
  lengthContrastEnabled: false
  allophoneRulesEnabled: false
normalization:
  classes:
    SYLLABIC_L_PREV_CONSONANT: ["p", "b", "t", "d", "k", "ɡ", "g", "f", "v", "θ", "ð", "s", "z", "ʃ", "ʒ", "h", "m", "n", "ŋ", "ɹ", "r", "ɾ", "j", "w", "l", "ɫ", "t͡ʃ", "d͡ʒ", "t͡s", "d͡z", "ʔ"]
  replacements:
    # eSpeak sometimes emits plain 'a' for TRAP. Your Python normalized that to 'æ'.
    - from: "a"
      to: "æ"

    # UK-ish long /uː/ (GOOSE) is typically more fronted than the generic /u/.
    # Our multilingual base 'u' is tuned fairly back; map long uː to a UK-specific key (ᵾ)
    # whose formants are closer to the older en-gb-tuned table.
    - from: "uː"
      to: "ᵾː"

    # Safety: some eSpeak voices omit the length mark in a few environments.
    # If that happens, still use the fronted English GOOSE vowel.
    - from: "u"
      to: "ᵾ"

    # Accent-specific vowel set tweaks live in per-region packs:
    #  - en-gb.yaml (BATH broadening, UK THOUGHT rounding, non-rhotic NURSE)
    #  - en-us.yaml (rhotic NURSE, narrow BATH, etc.)
    # FOOT vowel: eSpeak uses /ʊ/ in many common words ("book", "good", "could").
    # Our English-tuned variant opens it slightly so it doesn't collapse into GOOSE-like "boo".
    - from: "ʊ"
      to:   "ʊ̞"

    # Pre-fortis clipping: shorten long FLEECE before word-final /t/
    # so minimal pairs like "bead" vs "beat" are distinguishable.
    - from: "iːt"
      to:   "it"
      when:
        atWordEnd: true

    # NEAR vowel (fear, hear, dear): in classic eSpeak en-gb this is often /iə/.
    # In a Klatt-ish formant synth, iə can sound like two full vowel beats.
    # Collapse it to a single vowel with a very short schwa-like tail.
    - from: "iə"
      to:   "iᵊ"
      when:
        atWordEnd: true
    - from: "i͡ə"
      to:   "iᵊ"
      when:
        atWordEnd: true



    # Word-final /ɛɹ/ (square, fair, dare, where, there...):
    # In a formant synth, the vowel can get pulled into /r/ too quickly,
    # making it sound a bit "short" and overly rounded.
    # Add a very short schwa-like transition (ᵊ) before /r/.
    - from: "ɛɹ"
      to:   "ɛᵊɹ"
      when:
        atWordEnd: true

    # Word-final -teen/-tein "...tiːn" (thirteen, fourteen, fifteen, protein):
    # eSpeak often stresses the first syllable, which can make the /tiːn/ tail
    # sound clipped in our timing model.
    # Give the final syllable a light secondary stress so the vowel doesn't collapse.
    - from: "tiːn"
      # In en-us we shorten length-marked vowels in final codas.
      # If we keep ː here, the net timing can become too clipped ("tihn").
      # Removing the length mark keeps the vowel quality, but avoids the extra final-coda shortening.
      to:   "tˌin"
      when:
        atWordEnd: true
    # Word-final syllabic /l/ (able, google, poodle, people, etc.)
    # eSpeak usually emits these as schwa+L (ə l) or sometimes syllabic l (l̩).
    #
    # In a formant synth, schwa here can come out too front/central ("ö"-ish) and the /l/ can get lost.
    # Screen-reader voices (including Eloquence) often sound clearer if this ends more like "...-ohl".
    #
    # We do this generically (no word lists) by backing/rounding the nucleus:
    #   əl#  ->  ol#
    #
    # Note: en-us.yaml already slightly fronts "o" -> "ᵒ" for its GOAT vowel quality, so US vs UK stays sensible.
    - from: "əl"
      to:   "ol"
      when:
        atWordEnd: true
        afterClass: SYLLABIC_L_PREV_CONSONANT
    - from: "əɫ"
      to:   "ol"
      when:
        atWordEnd: true
        afterClass: SYLLABIC_L_PREV_CONSONANT
    - from: "@l"
      to:   "ol"
      when:
        atWordEnd: true
        afterClass: SYLLABIC_L_PREV_CONSONANT
    - from: "@ɫ"
      to:   "ol"
      when:
        atWordEnd: true
        afterClass: SYLLABIC_L_PREV_CONSONANT
    - from: "l̩"
      to:   "ol"
      when:
        atWordEnd: true
        afterClass: SYLLABIC_L_PREV_CONSONANT
    - from: "ɫ̩"
      to:   "ol"
      when:
        atWordEnd: true
        afterClass: SYLLABIC_L_PREV_CONSONANT
